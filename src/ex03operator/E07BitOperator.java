package ex03operator;

public class E07BitOperator {
	
	/*
	 비트연산자
	  - 값의 2진수로 변환하여 비트단위로 표현한 후 같은 비트 단위끼리 연산한 후 10진수로 다시 변환하여 출력
	  - & 비트단위로 AND 연산 : 둘 다 1일 경우 1을 반환, 아닐 경우 0을 반환
	  - | 비트단위로 OR 연산 : 둘 다 0일 경우 0을 반환, 아닐 경우 1을 반환
	  - ^ 비트단위로 XOR 연산 : 두개가 일치할 경우 0을 반환, 불일치할 경우 1을 반환
	  - ~ 피연산자의 모든 비트를 반전시킨다 : 1->0, 0->1
	 */
	public static void main(String[] args) {
		
		int num1 = 5;
		int num2 = 3;
		int num3 = -1;
		
		System.out.println("비트AND:"+ (num1 & num2)); // 101 과 011을 AND 연산 -> 001을 10진수로 변환-> 1 
		System.out.println("비트OR:"+ (num1 | num2)); // 101 과 011을 OR 연산 -> 111을 10진수로 변환-> 7
		System.out.println("비트XOR:"+ (num1 ^ num2)); // 
		System.out.println("비트Not:"+ (~num3));

	}
/*
 ※ 컴퓨터는 실질적으로 오로지 덧셈만 할 수 있다. 뺄셈은 1+(-2)로 덧셈, 곱셈은 덧셈 여러번, 나눗셈은 뺄셈 여러번의 방식으로 해결한다.
  
 십진수를 이진수로 바꾸는 법
  양수(+)
   - 2의 제곱으로 표현 할 수 있는 가장 큰 수로 뺄 수 있으면 1 없으면 0으로 해당 자리의 이진수를 결정하고 다음 자리로 넘어간다
   	ex) byte로 선언된 변수 a=30을 이진수로 바꾸면
   	  byte는 8비트 이므로 8자리 1111 1111 ~ 0000 0000(2^7~2^0) 사이 값을 갖는다
   	  30 - 16(2^4) - 8(2^3) - 4(2^2) - 2(2^1) = 0 이 되므로 이진수 0001 1110이다.
   	  
   음수(-) : 양수의 2의 보수라고 표현하기도 한다.(1의 2의 보수는 -1, 31의 2의 보수는 -31)
   - 음수를 이진수로 표현하기 위해서는 1의 보수와 2의 보수에 대한 이해가 필요
   
   - 1의 보수란 어떤 이진수를 반전시킨 값. 즉, 1은 0으로 0은 1로 변환시킨 값을 말한다.
   		ex) (십진수 30)0001 1110의 1의 보수는 1110 0001이다
   		
   - 2의 보수는 1의 보수에 1을 더해주면 된다
   		ex) (십진수 30)0001 1110의 1의 보수는 1110 0001에 1을 더해주면 1110 0010이 된다.
   		
   - 이렇게 만들어진 2의 보수는 음수(-)를 표현하게 된다. 즉 -30의 이진수는 1110 0010이다.
   
   - 음수에 대한 검증은 동일한 숫자의 양수와 음수를 더했을 때 결과값이 0임을 확인하는 것으로 할 수 있다.
   		ex) 30 :   0001 1110
   		   -30 :   1110 0010 
 		  +(0  : 1 0000 0000
 		   
 		   제일 앞에 한자리 수 커진 1은 정해진 bit수를 초과하므로 버려지게 되고 나머지 8bit가 모두 0이므로
 		   십진수 30+(-30)이 0, 이진수의 합도 0이므로 음수값의 이진수를 검증할 수 있다.

   - 반대로 말하면 어떤 음수의 이진수 값을 구하려면
     -부호를 제거한 양수의 이진수값을 해당 bit수보다 한자리 큰수가 1이며 나머지가 0인 이진수에서 빼면 된다
   		ex) -30 에서 -부호 빼면 양수 30, 30의 이진수 0001 1110을 1 0000 0000에서 뺀 결과값을 찾는다.
   			1 0000 0000
   		   -  0001 1110
   		   =  1110 0010 => -30

   - 1byte(8bit) 이상으로 표현되는 int나 double형도 자리수가 커질 뿐 위와 동일한 방법으로 음수값을 확인 할 수 있다. 
 */
}


